$date
	Mon Jul 12 01:19:27 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module testbench $end
$var wire 2 ! ResultSrc [1:0] $end
$var wire 1 " RegWrite $end
$var wire 2 # RegSrc [1:0] $end
$var wire 1 $ PCWrite $end
$var wire 1 % MemWrite $end
$var wire 2 & ImmSrc [1:0] $end
$var wire 1 ' IRWrite $end
$var wire 1 ( AdrSrc $end
$var wire 2 ) ALUSrcB [1:0] $end
$var wire 2 * ALUSrcA [1:0] $end
$var wire 2 + ALUControl [1:0] $end
$var reg 4 , ALUFlags [3:0] $end
$var reg 32 - Instr [31:0] $end
$var reg 1 . clk $end
$var reg 1 / reset $end
$scope module dut $end
$var wire 4 0 ALUFlags [3:0] $end
$var wire 20 1 Instr [31:12] $end
$var wire 1 . clk $end
$var wire 1 / reset $end
$var wire 2 2 ResultSrc [1:0] $end
$var wire 1 " RegWrite $end
$var wire 1 3 RegW $end
$var wire 2 4 RegSrc [1:0] $end
$var wire 1 $ PCWrite $end
$var wire 1 5 PCS $end
$var wire 1 6 NextPC $end
$var wire 1 % MemWrite $end
$var wire 1 7 MemW $end
$var wire 2 8 ImmSrc [1:0] $end
$var wire 1 ' IRWrite $end
$var wire 2 9 FlagW [1:0] $end
$var wire 1 ( AdrSrc $end
$var wire 2 : ALUSrcB [1:0] $end
$var wire 2 ; ALUSrcA [1:0] $end
$var wire 2 < ALUControl [1:0] $end
$scope module cl $end
$var wire 4 = ALUFlags [3:0] $end
$var wire 4 > Cond [3:0] $end
$var wire 1 ? CondEx $end
$var wire 2 @ FlagWrite [1:0] $end
$var wire 1 % MemWrite $end
$var wire 1 $ PCWrite $end
$var wire 1 " RegWrite $end
$var wire 1 . clk $end
$var wire 1 / reset $end
$var wire 1 3 RegW $end
$var wire 1 5 PCS $end
$var wire 1 6 NextPC $end
$var wire 1 7 MemW $end
$var wire 4 A Flags [3:0] $end
$var wire 2 B FlagW [1:0] $end
$scope module cc $end
$var wire 4 C Cond [3:0] $end
$var wire 4 D Flags [3:0] $end
$var wire 1 E ge $end
$var wire 1 F zero $end
$var wire 1 G overflow $end
$var wire 1 H neg $end
$var wire 1 I carry $end
$var reg 1 J CondEx $end
$upscope $end
$scope module condexes $end
$var wire 1 . clk $end
$var wire 8 K d [7:0] $end
$var wire 1 / reset $end
$var reg 8 L q [7:0] $end
$upscope $end
$scope module flagreg0 $end
$var wire 1 . clk $end
$var wire 2 M d [1:0] $end
$var wire 1 N en $end
$var wire 1 / reset $end
$var reg 2 O q [1:0] $end
$upscope $end
$scope module flagreg1 $end
$var wire 1 . clk $end
$var wire 2 P d [1:0] $end
$var wire 1 Q en $end
$var wire 1 / reset $end
$var reg 2 R q [1:0] $end
$upscope $end
$scope module flagwritereg $end
$var wire 1 . clk $end
$var wire 2 S d [1:0] $end
$var wire 1 / reset $end
$var reg 2 T q [1:0] $end
$upscope $end
$upscope $end
$scope module dec $end
$var wire 6 U Funct [5:0] $end
$var wire 2 V ImmSrc [1:0] $end
$var wire 2 W Op [1:0] $end
$var wire 1 5 PCS $end
$var wire 4 X Rd [3:0] $end
$var wire 1 . clk $end
$var wire 1 / reset $end
$var wire 2 Y ResultSrc [1:0] $end
$var wire 1 3 RegW $end
$var wire 2 Z RegSrc [1:0] $end
$var wire 1 6 NextPC $end
$var wire 1 7 MemW $end
$var wire 1 ' IRWrite $end
$var wire 1 [ Branch $end
$var wire 1 ( AdrSrc $end
$var wire 2 \ ALUSrcB [1:0] $end
$var wire 2 ] ALUSrcA [1:0] $end
$var wire 1 ^ ALUOp $end
$var reg 2 _ ALUControl [1:0] $end
$var reg 2 ` FlagW [1:0] $end
$scope module fsm $end
$var wire 6 a Funct [5:0] $end
$var wire 2 b Op [1:0] $end
$var wire 1 . clk $end
$var wire 1 / reset $end
$var wire 2 c ResultSrc [1:0] $end
$var wire 1 3 RegW $end
$var wire 1 6 NextPC $end
$var wire 1 7 MemW $end
$var wire 1 ' IRWrite $end
$var wire 1 [ Branch $end
$var wire 1 ( AdrSrc $end
$var wire 2 d ALUSrcB [1:0] $end
$var wire 2 e ALUSrcA [1:0] $end
$var wire 1 ^ ALUOp $end
$var reg 13 f controls [12:0] $end
$var reg 4 g nextstate [3:0] $end
$var reg 4 h state [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module top $end
$var wire 32 i Adr [31:0] $end
$var wire 32 j WriteData [31:0] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 32 m ReadData [31:0] $end
$var wire 1 n MemWrite $end
$scope module arm $end
$var wire 4 o ALUFlags [3:0] $end
$var wire 32 p Adr [31:0] $end
$var wire 32 q WriteData [31:0] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 2 r ResultSrc [1:0] $end
$var wire 1 s RegWrite $end
$var wire 2 t RegSrc [1:0] $end
$var wire 32 u ReadData [31:0] $end
$var wire 1 v PCWrite $end
$var wire 1 n MemWrite $end
$var wire 32 w Instr [31:0] $end
$var wire 2 x ImmSrc [1:0] $end
$var wire 1 y IRWrite $end
$var wire 1 z AdrSrc $end
$var wire 2 { ALUSrcB [1:0] $end
$var wire 2 | ALUSrcA [1:0] $end
$var wire 2 } ALUControl [1:0] $end
$scope module c $end
$var wire 4 ~ ALUFlags [3:0] $end
$var wire 20 !" Instr [31:12] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 2 "" ResultSrc [1:0] $end
$var wire 1 s RegWrite $end
$var wire 1 #" RegW $end
$var wire 2 $" RegSrc [1:0] $end
$var wire 1 v PCWrite $end
$var wire 1 %" PCS $end
$var wire 1 &" NextPC $end
$var wire 1 n MemWrite $end
$var wire 1 '" MemW $end
$var wire 2 (" ImmSrc [1:0] $end
$var wire 1 y IRWrite $end
$var wire 2 )" FlagW [1:0] $end
$var wire 1 z AdrSrc $end
$var wire 2 *" ALUSrcB [1:0] $end
$var wire 2 +" ALUSrcA [1:0] $end
$var wire 2 ," ALUControl [1:0] $end
$scope module cl $end
$var wire 4 -" ALUFlags [3:0] $end
$var wire 4 ." Cond [3:0] $end
$var wire 1 /" CondEx $end
$var wire 2 0" FlagWrite [1:0] $end
$var wire 1 n MemWrite $end
$var wire 1 v PCWrite $end
$var wire 1 s RegWrite $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 1 #" RegW $end
$var wire 1 %" PCS $end
$var wire 1 &" NextPC $end
$var wire 1 '" MemW $end
$var wire 4 1" Flags [3:0] $end
$var wire 2 2" FlagW [1:0] $end
$scope module cc $end
$var wire 4 3" Cond [3:0] $end
$var wire 4 4" Flags [3:0] $end
$var wire 1 5" ge $end
$var wire 1 6" zero $end
$var wire 1 7" overflow $end
$var wire 1 8" neg $end
$var wire 1 9" carry $end
$var reg 1 :" CondEx $end
$upscope $end
$scope module condexes $end
$var wire 1 k clk $end
$var wire 8 ;" d [7:0] $end
$var wire 1 l reset $end
$var reg 8 <" q [7:0] $end
$upscope $end
$scope module flagreg0 $end
$var wire 1 k clk $end
$var wire 2 =" d [1:0] $end
$var wire 1 >" en $end
$var wire 1 l reset $end
$var reg 2 ?" q [1:0] $end
$upscope $end
$scope module flagreg1 $end
$var wire 1 k clk $end
$var wire 2 @" d [1:0] $end
$var wire 1 A" en $end
$var wire 1 l reset $end
$var reg 2 B" q [1:0] $end
$upscope $end
$scope module flagwritereg $end
$var wire 1 k clk $end
$var wire 2 C" d [1:0] $end
$var wire 1 l reset $end
$var reg 2 D" q [1:0] $end
$upscope $end
$upscope $end
$scope module dec $end
$var wire 6 E" Funct [5:0] $end
$var wire 2 F" ImmSrc [1:0] $end
$var wire 2 G" Op [1:0] $end
$var wire 1 %" PCS $end
$var wire 4 H" Rd [3:0] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 2 I" ResultSrc [1:0] $end
$var wire 1 #" RegW $end
$var wire 2 J" RegSrc [1:0] $end
$var wire 1 &" NextPC $end
$var wire 1 '" MemW $end
$var wire 1 y IRWrite $end
$var wire 1 K" Branch $end
$var wire 1 z AdrSrc $end
$var wire 2 L" ALUSrcB [1:0] $end
$var wire 2 M" ALUSrcA [1:0] $end
$var wire 1 N" ALUOp $end
$var reg 2 O" ALUControl [1:0] $end
$var reg 2 P" FlagW [1:0] $end
$scope module fsm $end
$var wire 6 Q" Funct [5:0] $end
$var wire 2 R" Op [1:0] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 2 S" ResultSrc [1:0] $end
$var wire 1 #" RegW $end
$var wire 1 &" NextPC $end
$var wire 1 '" MemW $end
$var wire 1 y IRWrite $end
$var wire 1 K" Branch $end
$var wire 1 z AdrSrc $end
$var wire 2 T" ALUSrcB [1:0] $end
$var wire 2 U" ALUSrcA [1:0] $end
$var wire 1 N" ALUOp $end
$var reg 13 V" controls [12:0] $end
$var reg 4 W" nextstate [3:0] $end
$var reg 4 X" state [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 2 Y" ALUControl [1:0] $end
$var wire 4 Z" ALUFlags [3:0] $end
$var wire 2 [" ALUSrcA [1:0] $end
$var wire 2 \" ALUSrcB [1:0] $end
$var wire 32 ]" Adr [31:0] $end
$var wire 1 z AdrSrc $end
$var wire 1 y IRWrite $end
$var wire 2 ^" ImmSrc [1:0] $end
$var wire 1 v PCWrite $end
$var wire 2 _" RegSrc [1:0] $end
$var wire 1 s RegWrite $end
$var wire 2 `" ResultSrc [1:0] $end
$var wire 32 a" WriteData [31:0] $end
$var wire 1 k clk $end
$var wire 1 l reset $end
$var wire 32 b" ReadData [31:0] $end
$var wire 32 c" Instr [31:0] $end
$scope module datos $end
$var wire 1 k clk $end
$var wire 8 d" d [7:0] $end
$var wire 1 y en $end
$var wire 1 l reset $end
$var reg 8 e" q [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem $end
$var wire 32 f" a [31:0] $end
$var wire 1 k clk $end
$var wire 32 g" rd [31:0] $end
$var wire 32 h" wd [31:0] $end
$var wire 1 n we $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bz h"
bx g"
bz f"
bx e"
bx d"
b0xxxxxxxx c"
bx b"
bz a"
bx `"
b0 _"
b0 ^"
bz ]"
bx \"
bx ["
bz Z"
b0 Y"
bx X"
bx W"
bx V"
bx U"
bx T"
bx S"
b0 R"
b0 Q"
b0 P"
b0 O"
xN"
bx M"
bx L"
xK"
b0 J"
bx I"
b0 H"
b0 G"
b0 F"
b0 E"
bx D"
b0 C"
bx B"
xA"
bz @"
bx ?"
x>"
bz ="
bx <"
b0x ;"
x:"
x9"
x8"
x7"
x6"
x5"
bx 4"
b0 3"
b0 2"
bx 1"
bx 0"
x/"
b0 ."
bz -"
b0 ,"
bx +"
bx *"
b0 )"
b0 ("
x'"
x&"
x%"
b0 $"
x#"
bx ""
b0 !"
bz ~
b0 }
bx |
bx {
xz
xy
b0 x
b0xxxxxxxx w
xv
bx u
b0 t
xs
bx r
bz q
bz p
bz o
xn
bx m
zl
zk
bz j
bz i
b0 h
b1 g
b1000101001100 f
b1 e
b10 d
b10 c
bx b
bx a
b0 `
b0 _
0^
b1 ]
b10 \
0[
bx Z
b10 Y
bx X
bx W
bx V
bx U
b0 T
b0 S
b0 R
0Q
bx P
b0 O
0N
bx M
b0 L
b0x K
xJ
0I
0H
0G
0F
1E
b0 D
bx C
b0 B
b0 A
b0 @
x?
bx >
bx =
b0 <
b1 ;
b10 :
b0 9
bx 8
07
16
05
bx 4
03
b10 2
bx 1
bx 0
1/
1.
bx -
bx ,
b0 +
b1 *
b10 )
0(
1'
bx &
0%
1$
bx #
0"
b10 !
$end
#1
0.
0/
1J
b0 &
b0 8
b0 V
b0 #
b0 4
b0 Z
b0 W
b0 b
b101000 U
b101000 a
b10 X
b1110 >
b1110 C
b0 P
b0 M
b11100010100000000010 1
b0 ,
b0 0
b0 =
b11100010100000000010000000000001 -
#2
0$
06
0'
b111 g
b1001100 f
b0x L
b1 h
1.
#3
0.
#4
b0 !
b0 2
b0 Y
b0 c
b0 *
b0 ;
b0 ]
b0 e
b1 )
b1 :
b1 \
b1 d
1^
b11 f
b1000 g
b111 h
1.
#5
0.
#6
x"
13
b0 )
b0 :
b0 \
b0 d
0^
b0 g
b1000000000 f
b1000 h
1.
#7
0.
#8
1$
0"
16
03
1'
b10 !
b10 2
b10 Y
b10 c
b1 *
b1 ;
b1 ]
b1 e
b10 )
b10 :
b10 \
b10 d
b1000101001100 f
b1 g
b0 h
1.
#9
0.
#10
0$
06
0'
b111 g
b1001100 f
b1 h
1.
#11
0.
b10 &
b10 8
b10 V
b1 #
b1 4
b1 Z
b10 W
b10 b
b100000 U
b100000 a
b0 X
b11 M
b11101010000000000000 1
b11 ,
b11 0
b11 =
b11101010000000000000000000000001 -
#12
b10 +
b10 <
b10 _
b0 !
b0 2
b0 Y
b0 c
b0 *
b0 ;
b0 ]
b0 e
b1 )
b1 :
b1 \
b1 d
1^
b11 f
b1000 g
b111 h
1.
#13
0.
#14
x"
b0 +
b0 <
b0 _
13
b0 )
b0 :
b0 \
b0 d
0^
b0 g
b1000000000 f
b1000 h
1.
#15
0.
#16
1$
0"
16
03
1'
b10 !
b10 2
b10 Y
b10 c
b1 *
b1 ;
b1 ]
b1 e
b10 )
b10 :
b10 \
b10 d
b1000101001100 f
b1 g
b0 h
1.
#17
0.
#18
0$
06
0'
b1001 g
b1001100 f
b1 h
1.
#19
0.
#20
x$
15
1[
b0 *
b0 ;
b0 ]
b0 e
b1 )
b1 :
b1 \
b1 d
b100001000010 f
b0 g
b1001 h
1.
#21
0.
b1 &
b1 8
b1 V
b10 #
b10 4
b10 Z
b1 W
b1 b
b11001 U
b11001 a
b10 X
b10 P
b11100101100100000010 1
b1011 ,
b1011 0
b1011 =
b11100101100100000010000001100000 -
#22
1$
05
16
0[
1'
b1 *
b1 ;
b1 ]
b1 e
b10 )
b10 :
b10 \
b10 d
b1 g
b1000101001100 f
b0 h
1.
#23
0.
#24
0$
06
0'
b1001100 f
b10 g
b1 h
1.
#25
0.
#26
b0 !
b0 2
b0 Y
b0 c
b0 *
b0 ;
b0 ]
b0 e
b1 )
b1 :
b1 \
b1 d
b11 g
b10 f
b10 h
1.
#27
0.
#28
1(
b0 )
b0 :
b0 \
b0 d
b10000000 f
b100 g
b11 h
1.
#29
0.
#30
x"
13
0(
b1 !
b1 2
b1 Y
b1 c
b0 g
b1000100000 f
b100 h
1.
#31
0.
b11000 U
b11000 a
b11100101100000000010 1
b11100101100000000010000001010100 -
#32
1$
0"
16
03
1'
b10 !
b10 2
b10 Y
b10 c
b1 *
b1 ;
b1 ]
b1 e
b10 )
b10 :
b10 \
b10 d
b1000101001100 f
b1 g
b0 h
1.
#33
0.
#34
0$
06
0'
b10 g
b1001100 f
b1 h
1.
#35
0.
#36
b0 !
b0 2
b0 Y
b0 c
b0 *
b0 ;
b0 ]
b0 e
b1 )
b1 :
b1 \
b1 d
b10 f
b101 g
b10 h
1.
#37
0.
#38
x%
17
1(
b0 )
b0 :
b0 \
b0 d
b0 g
b10010000000 f
b101 h
1.
#39
0.
#40
1$
0%
16
07
1'
0(
b10 !
b10 2
b10 Y
b10 c
b1 *
b1 ;
b1 ]
b1 e
b10 )
b10 :
b10 \
b10 d
b1000101001100 f
b1 g
b0 h
1.
#41
0.
